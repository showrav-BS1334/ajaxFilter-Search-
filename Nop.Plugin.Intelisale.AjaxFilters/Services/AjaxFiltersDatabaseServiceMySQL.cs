using Nop.Plugin.Intelisale.AjaxFilters.Domain;
using Nop.Core.Infrastructure;
using Nop.Data;
using Nop.Services.Configuration;
using Nop.Services.Security;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace Nop.Plugin.Intelisale.AjaxFilters.Services
{
    public class AjaxFiltersDatabaseServiceMySQL : IAjaxFiltersDatabaseService
    {
        private const string EncryptionKey = "SS_AjaxFilters_EK_351";

        private readonly INopDataProvider _dataProvider;

        private readonly IEncryptionService _encryptionService;

        private readonly ISettingService _settingService;

        private string CreateStoredProcedureSql = "DELIMITER $$\nCREATE PROCEDURE `ProductLoadAllPagedNopAjaxFilters`(\n\t\t`CategoryIds`\t\t\t\t\t\t\t\t\t\ttext,\t\t\t\t#a list of category IDs (comma-separated list). e.g. 1,2,3\n\t\t`ManufacturerId`\t\t\t\t\t\t\t\t\tint,\n\t\t`StoreId`\t\t\t\t\t\t\t\t\t\t\tint,\n\t\t`VendorId`\t\t\t\t\t\t\t\t\t\t\tint,\n\t\t`ParentGroupedProductId`\t\t\t\t\t\t\tint,\n\t\t`ProductTypeId`\t\t\t\t\t\t\t\t\t\tint, \t\t\t\t#product type identifier, null - load all products\n\t\t`VisibleIndividuallyOnly` \t\t\t\t\t\t\tbool, \t\t\t\t#0 - load all products , 1 - \"visible indivially\" only\n\t\t`ProductTagId`\t\t\t\t\t\t\t\t\t\tint,\n\t\t`FeaturedProducts`\t\t\t\t\t\t\t\t\tbool,\t\t\t\t#0 featured only , 1 not featured only, null - load all products\n\t\t`PriceMin`\t\t\t\t\t\t\t\t\t\t\tdecimal(18, 4),\n\t\t`PriceMax`\t\t\t\t\t\t\t\t\t\t\tdecimal(18, 4),\n\t\t`Keywords`\t\t\t\t\t\t\t\t\t\t\ttext,\n\t\t`SearchDescriptions` \t\t\t\t\t\t\t\tbool, \t\t\t\t#a value indicating whether to search by a specified \"keyword\" in product descriptions\n\t\t`SearchManufacturerPartNumber` \t\t\t\t\t\tbool, \t\t\t\t# a value indicating whether to search by a specified \"keyword\" in manufacturer part number\n\t\t`SearchSku`\t\t\t\t\t\t\t\t\t\t\tbool, \t\t\t\t#a value indicating whether to search by a specified \"keyword\" in product SKU\n\t\t`SearchProductTags`  \t\t\t\t\t\t\t\tbool, \t\t\t\t#a value indicating whether to search by a specified \"keyword\" in product tags\n\t\t`UseFullTextSearch`  \t\t\t\t\t\t\t\tbool,\n\t\t`FullTextMode`\t\t\t\t\t\t\t\t\t\tint, \t\t\t\t#0 - using CONTAINS with <prefix_term>, 5 - using CONTAINS and OR with <prefix_term>, 10 - using CONTAINS and AND with <prefix_term>\n\t\t`FilteredSpecs`\t\t\t\t\t\t\t\t\t\ttext,\t\t\t\t#filter by specification attribute options (comma-separated list of IDs). e.g. 14,15,16\n\t\t`FilteredProductVariantAttributes`\t\t\t\t\ttext,\n\t\t`FilteredManufacturers`\t\t\t\t\t\t\t\ttext,\n\t\t`FilteredVendors`\t\t\t\t\t\t\t\t\ttext,\n\t\t`OnSale`\t\t\t\t\t\t\t\t\t\t\tbool,\n\t\t`InStock`\t\t\t\t\t\t\t\t\t\t\tbool,\n\t\t`LanguageId`\t\t\t\t\t\t\t\t\t\tint,\n\t\t`OrderBy`\t\t\t\t\t\t\t\t\t\t\tint, \t\t\t\t#0 - position, 5 - Name: A to Z, 6 - Name: Z to A, 10 - Price: Low to High, 11 - Price: High to Low, 15 - creation date\n\t\t`AllowedCustomerRoleIds`\t\t\t\t\t\t\ttext,\t\t\t\t#a list of customer role IDs (comma-separated list) for which a product should be shown (if a subject to ACL)\n\t\t`PageIndex`\t\t\t\t\t\t\t\t\t\t\tint, \n\t\t`PageSize`\t\t\t\t\t\t\t\t\t\t\tint,\n\t\t`ShowHidden`\t\t\t\t\t\t\t\t\t\tbool,\n\t\t`LoadAvailableFilters`\t\t\t\t\t\t\t\tbool,\t\t\t\t#a value indicating whether we should load the specification attribute option identifiers applied to loaded products (all pages)\n\t\tout\t`FilterableSpecificationAttributeOptionIds` \ttext, \t\t\t\t#the specification attribute option identifiers applied to loaded products (all pages). returned as a comma separated list of identifiers\n\t\tout `FilterableProductVariantAttributeIds`\t\t\ttext,\n\t\tout `FilterableManufacturerIds`\t\t\t\t\t\ttext,\n\t\tout `FilterableVendorIds`\t\t\t\t\t\t\ttext,\n\t\t`IsOnSaleFilterEnabled` \t\t\t\t\t\t\tbool,\n\t\t`IsInStockFilterEnabled`\t\t\t\t\t\t\tbool,\n\t\tout `HasProductsOnSale`\t\t\t\t\t\t\t\tbool,\t\t\t\t#a value indicating whether we should load the on sale filter\n\t\tout `HasProductsInStock`\t\t\t\t\t\t\tbool,\t\t\t\t#a value indicating whether we should load the in stock filter\n\t\tout\t`TotalRecords`\t\t\t\t\t\t\t\t\tint\n)\n\n    READS SQL DATA \n    SQL SECURITY INVOKER\nBEGIN\t\n\n\t# The filtering mechanism and the calculation of the available filters is based on the assumption\n\t# that only simple and grouped products, which are mapped to the specified category, manufacturer or vendor\n\t# are being filtered by specifications and manufacturers. Grouped products with child products are being filtered by price\n\t# and attributes by taking into account the price and the attributes of the child products only.\n\n\tDECLARE `SearchKeywords` bit default false;\n\tDECLARE `sqlWithoutFilters` text;\n\tDECLARE `sql_orderby` text;\n\tDECLARE `SpecificationAttributesCount` int;\n\tDECLARE `ProductAttributesCount` int;\n\tDECLARE `ManufacturersCount` int;\t\n\tDECLARE `VendorsCount` int;\t\n\t\n    Set @sql_command = '';\n    \n    /* Products that filtered by keywords */\n\tCREATE temporary TABLE `KeywordProducts`\n\t(\n\t\t`ProductId` int NOT NULL\n\t);\n    \n\tSet @Keywords = trim(COALESCE(`Keywords`, ''));\n    SET @OriginalKeywords = @Keywords;\n    \n    IF @Keywords != '' then\n\t\tSET `SearchKeywords` = true;\n        IF `UseFullTextSearch` then\n\t\t\t#remove wrong chars (' \")\n\t\t\tSET @Keywords = REPLACE(@Keywords, '''', '');\n\t\t\tSET @Keywords = REPLACE(@Keywords, '\"', '');\n            set @Keywords = concat(' ', @Keywords);\n            \n            IF `FullTextMode` = 0 then\n\t\t\t\tSET @Keywords = concat(' \"', @Keywords, '*\" ');\n\t\t\telse\n\t\t\t\t#5 - using CONTAINS and OR with <prefix_term>\n\t\t\t\t#10 - using CONTAINS and AND with <prefix_term>\n\n\t\t\t\t#clean multiple spaces\n                WHILE instr(@Keywords, '  ') > 0 do\n\t\t\t\t\tSET @Keywords = REPLACE(@Keywords, '  ', ' ');\n\t\t\t\tend while;\n\n\t\t\t\tIF `FullTextMode` = 5 then #5 - using CONTAINS and OR with <prefix_term>\n\t\t\t\t\tSET @concat_term = ' ';\n\t\t\t\tEND if;\n\t\t\t\tIF `FullTextMode` = 10 then #10 - using CONTAINS and AND with <prefix_term>\n\t\t\t\t\tSET @concat_term = ' +';\n\t\t\t\tEND if;\n                \n                #now let's build search string\n\t\t\t\tset @fulltext_keywords = '';\n\t\t\t\tset @str_index = instr(@Keywords, ' ');\n                \n                # if index = 0, then only one field was passed\n\t\t\t\tIF(@str_index = 0) then\n\t\t\t\t\tset @fulltext_keywords = concat(' \"', @Keywords, '*\" ');\n\t\t\t\tELSE\n\t\t\t\t\tset @fulltext_keywords = replace(@Keywords, ' ', @concat_term);\n                end if;\n                SET @Keywords = @fulltext_keywords;\n            end if;\n        end if;\n        \n        #product name\n\t\tSET @sql_command = '\n\t\tINSERT INTO `KeywordProducts` (ProductId)\n\t\tSELECT p.Id\n\t\tFROM Product p\n\t\tWHERE ';\n        \n\t\tIF UseFullTextSearch then\n\t\t\tSET @sql_command = concat(@sql_command, 'MATCH (p.`Name`) AGAINST (@Keywords IN BOOLEAN MODE) ');\n\t\tELSE\n\t\t\tSET @sql_command = concat(@sql_command, 'instr(p.Name, @Keywords) > 0 ');\n        end if;\n        \n        #localized product name        \n\t\tSET @sql_command = concat(@sql_command, '\n\t\tUNION\n\t\tSELECT lp.EntityId\n\t\tFROM LocalizedProperty lp\n\t\tWHERE\n\t\t\tlp.LocaleKeyGroup = ''Product''\n\t\t\tAND lp.LanguageId = ', `LanguageId`, '\n\t\t\tAND lp.LocaleKey = ''Name''');\n            \n\t\tIF UseFullTextSearch = 1 then\n\t\t\tSET @sql_command = concat(@sql_command, ' AND MATCH (lp.LocaleValue) AGAINST (@Keywords IN BOOLEAN MODE) ');\n\t\tELSE\n\t\t\tSET @sql_command = concat(@sql_command, ' AND instr(lp.LocaleValue, @Keywords) > 0 ');\n\t\tend if;\n        \n        if `SearchDescriptions` then\n\t\t\t#product short description\n\t\t\tSET @sql_command = concat(@sql_command, '\n\t\t\tUNION\n\t\t\tSELECT p.Id\n\t\t\tFROM Product p\n\t\t\tWHERE ');\n            \n\t\t\tIF `UseFullTextSearch` then\n\t\t\t\tSET @sql_command = concat(@sql_command, 'MATCH (p.ShortDescription, p.FullDescription) AGAINST (@Keywords IN BOOLEAN MODE) ');\n\t\t\tELSE\n\t\t\t\tSET @sql_command = concat(@sql_command, 'instr(p.ShortDescription, @Keywords) > 0 or instr(p.FullDescription, @Keywords) > 0 ');\n\t\t\tend if;\n\n\t\t\t#localized product short description\n\t\t\tSET @sql_command = concat(@sql_command, '\n\t\t\tUNION\n\t\t\tSELECT lp.EntityId\n\t\t\tFROM LocalizedProperty lp\n\t\t\tWHERE\n\t\t\t\tlp.LocaleKeyGroup = ''Product''\n\t\t\t\tAND lp.LanguageId = ', `LanguageId`, '\n\t\t\t\tAND lp.LocaleKey = ''ShortDescription''');\n                \n\t\t\tIF `UseFullTextSearch` then\n\t\t\t\tSET @sql_command =  concat(@sql_command, ' AND MATCH (lp.LocaleValue) AGAINST (@Keywords IN BOOLEAN MODE) ');\n\t\t\tELSE\n\t\t\t\tSET @sql_command = concat(@sql_command, ' AND instr(lp.LocaleValue, @Keywords) > 0 ');\n\t\t\tend if;\n\n\t\t\t#localized product full description\n\t\t\tSET @sql_command = concat(@sql_command, '\n\t\t\tUNION\n\t\t\tSELECT lp.EntityId\n\t\t\tFROM LocalizedProperty lp\n\t\t\tWHERE\n\t\t\t\tlp.LocaleKeyGroup = N''Product''\n\t\t\t\tAND lp.LanguageId = ', `LanguageId`, '\n\t\t\t\tAND lp.LocaleKey = N''FullDescription''');\n                \n\t\t\tIF `UseFullTextSearch` then\n\t\t\t\tSET @sql_command = concat(@sql_command, ' AND MATCH (lp.LocaleValue) AGAINST (@Keywords IN BOOLEAN MODE) ');\n\t\t\tELSE\n\t\t\t\tSET @sql_command = concat(@sql_command, ' AND instr(lp.LocaleValue, @Keywords) > 0 ');\n\t\t\tend if;\n            \n            \n        end if;\n        \n        #manufacturer part number (exact match)\n\t\tIF `SearchManufacturerPartNumber` then\n\t\t\tSET @sql_command = concat(@sql_command, '\n\t\t\tUNION\n\t\t\tSELECT p.Id\n\t\t\tFROM Product p\n\t\t\tWHERE p.ManufacturerPartNumber = @OriginalKeywords ');\n\t\tEND if;\n\n\t\t#SKU (exact match)\n\t\tIF `SearchSku` then\n\t\t\tSET @sql_command = concat(@sql_command, '\n\t\t\tUNION\n\t\t\tSELECT p.Id\n\t\t\tFROM Product p\n\t\t\tWHERE p.Sku = @OriginalKeywords ');\n\t\tEND if;\n        \n        IF `SearchProductTags` then\n\t\t\t#product tags (exact match)\n\t\t\tSET @sql_command = concat(@sql_command, '\n\t\t\tUNION\n\t\t\tSELECT pptm.Product_Id\n\t\t\tFROM Product_ProductTag_Mapping pptm INNER JOIN ProductTag pt ON pt.Id = pptm.ProductTag_Id\n\t\t\tWHERE pt.`Name` = @OriginalKeywords ');\n\n\t\t\t#localized product tags\n\t\t\tSET @sql_command = concat(@sql_command, '\n\t\t\tUNION\n\t\t\tSELECT pptm.Product_Id\n\t\t\tFROM LocalizedProperty lp INNER JOIN Product_ProductTag_Mapping pptm ON lp.EntityId = pptm.ProductTag_Id\n\t\t\tWHERE\n\t\t\t\tlp.LocaleKeyGroup = N''ProductTag''\n\t\t\t\tAND lp.LanguageId = ', `LanguageId`, '\n\t\t\t\tAND lp.LocaleKey = N''Name''\n\t\t\t\tAND lp.`LocaleValue` = @OriginalKeywords ');\n\t\tEND if;\n        \n        #select  @sql_command, @Keywords, @OriginalKeywords; #debug\n        \n        PREPARE sql_stmts FROM @sql_command;\n\t\tEXECUTE sql_stmts;\n\t\tDEALLOCATE PREPARE sql_stmts;\n    end if;\n    \n    create temporary table `DisplayOrderTmp`\n\t(\n\t\tId int NOT NULL auto_increment,\n\t\tProductId int NOT NULL,\n\t\tChildProductId int,\n        PRIMARY KEY (id)\n\t);\n\n    #filter by category IDs\n\tSET `CategoryIds` = COALESCE(`CategoryIds`, '');\n\t\n\t# LEFT JOIN the products with their child products\n\t# the child products if any will be used to filter by price and attributes\t\n    SET @sql_command = '\n\tINSERT INTO DisplayOrderTmp (ProductId, ChildProductId)\n\tSELECT p.Id, COALESCE(cp.Id, 0)\n\tFROM \n\t\tProduct p\n\t\tLEFT JOIN Product cp\n\t\tON p.Id = cp.ParentGroupedProductId';\n\t\t\t\t    \n    IF `CategoryIds` REGEXP '^([[:digit:]](,?))+$' then\n\t\tSET @sql_command = concat(@sql_command, '\n\t\tLEFT JOIN Product_Category_Mapping pcm ON p.Id = pcm.ProductId');\n\tEND if;\n    \n    IF `ManufacturerId` > 0 OR `FilteredManufacturers` REGEXP '^([[:digit:]](,?))+$' then\n\t\tSET @sql_command = concat(@sql_command, '\n\t\tLEFT JOIN Product_Manufacturer_Mapping pmm\n\t\t\tON p.Id = pmm.ProductId');\n\tEND if;\n    \n    IF COALESCE(`ProductTagId`, 0) != 0 then\n\t\tSET @sql_command = concat(@sql_command, '\n\t\tLEFT JOIN Product_ProductTag_Mapping pptm\n\t\t\tON p.Id = pptm.Product_Id');\n\tEND if;\n    \n    #searching by keywords\n\tIF `SearchKeywords` then\n\t\tSET @sql_command = concat(@sql_command, '\n\t\tJOIN `KeywordProducts` kp\n\t\t\tON  p.Id = kp.ProductId');\n\tEND if;\n    \n    SET @sql_command = concat(@sql_command, '\n\t\tWHERE\n\t\t\tp.Deleted = 0 AND (p.ParentGroupedProductId = 0 OR p.VisibleIndividually = 1)');         \n    \n    #filter by category\n\tIF `CategoryIds` REGEXP '^([[:digit:]](,?))+$' then\n\t\tSET @sql_command = concat(@sql_command, '\n\t\tAND pcm.CategoryId IN (', `CategoryIds`, ')');\t\t\n\n\t\tIF `FeaturedProducts` IS NOT NULL then\n\t\t\tSET @sql_command = concat(@sql_command, '\n\t\t\t\tAND pcm.IsFeaturedProduct = ', `FeaturedProducts`);\n\t\tEND if;\n\tEND if;\n\n\t# filter by specification attributes\n\tcreate temporary table `FilteredSpecificationAttributeOptions`\n\t(\n\t\tSpecificationAttributeOptionId int not null unique\n\t);\t\n\n\tIF `FilteredSpecs` REGEXP '^([[:digit:]](,?))+$' then\n\n\t\tdrop table if exists t;\n\t\tcreate temporary table t\n\t\t( \n\t\t\ttxt text \n\t\t);\n\n\t\tINSERT INTO t values(FilteredSpecs);\n\n\t\tdrop table if exists `FilteredSpecsTmp`;\n\t\tcreate temporary table `FilteredSpecsTmp`\n\t\t( \n\t\t\tSpecificationAttributeOptionId text \n\t\t);\n\n\t\tset @sql1 = concat(\"insert into FilteredSpecsTmp (SpecificationAttributeOptionId) values ('\", replace(( select group_concat(distinct txt) as data from t), \",\", \"'),('\"),\"');\");\n\t\tprepare stmt1 from @sql1;\n\t\texecute stmt1;\n\n\t\tINSERT INTO FilteredSpecificationAttributeOptions\n\t\tSELECT CAST(SpecificationAttributeOptionId AS UNSIGNED)\n\t\tFROM `FilteredSpecsTmp`;\n\n\t\tSET `SpecificationAttributesCount` = \n\t\t(\n\t\t\tSELECT COUNT(DISTINCT sao.SpecificationAttributeId) FROM `FilteredSpecificationAttributeOptions` fs \n\t\t\tINNER JOIN `SpecificationAttributeOption` sao ON sao.Id = fs.SpecificationAttributeOptionId \n\t\t);\n\n\tend if;\n    \n\tcreate temporary table `FilteredSpecificationAttributes`\n\t(\n\t\tAttributeId int not null,\n\t\tINDEX(AttributeId)\n\t);\n\n\tINSERT INTO `FilteredSpecificationAttributes`\n\tSELECT DISTINCT sap.SpecificationAttributeId\n\tFROM SpecificationAttributeOption sap\n\tINNER JOIN `FilteredSpecificationAttributeOptions` fs ON fs.SpecificationAttributeOptionId = sap.Id;\n\n\t# filter by attributes\n\tcreate temporary table `FilteredProductVariantAttributeIds`\n\t(\n\t\tProductVariantAttributeId int not null\n\t);\n\n\tIF `FilteredProductVariantAttributes` REGEXP '^([[:digit:]](,?))+$' then\n\n\t\tdrop table if exists t;\n\t\tcreate temporary table t\n\t\t( \n\t\t\ttxt text \n\t\t);\n\n\t\tINSERT INTO t values(FilteredProductVariantAttributes);\n        \n\t\tset @sql1 = concat(\"insert into FilteredProductVariantAttributeIds (ProductVariantAttributeId) values ('\", replace(( select group_concat(distinct txt) as data from t), \",\", \"'),('\"),\"');\");\n\t\tprepare stmt1 from @sql1;\n\t\texecute stmt1;\n\tend if;\n\t\n\tSET `ProductAttributesCount` = (SELECT COUNT(DISTINCT ppm.ProductAttributeId) FROM `FilteredProductVariantAttributeIds` fpva \n\t\t\t\t\t\t\t\t\tINNER JOIN Product_ProductAttribute_Mapping ppm ON ppm.Id = fpva.ProductVariantAttributeId );\n\n\tcreate temporary table `FilteredProductAttributes`\n\t(\n\t\tAttributeId int not null\n\t);\n\n\tINSERT INTO `FilteredProductAttributes`\n\tSELECT DISTINCT ProductAttributeId\n\tFROM Product_ProductAttribute_Mapping ppm\n\tINNER JOIN `FilteredProductVariantAttributeIds` fpv ON fpv.ProductVariantAttributeId = ppm.Id;\n\n\t# filter by manufacturer attributes\n\tcreate temporary table `FilteredManufacturerIds`\n\t(\n\t\tManufacturerId int not null\n\t);\n\n\tIF `FilteredManufacturers` REGEXP '^([[:digit:]](,?))+$' then\n\n\t\tdrop table if exists t;\n\t\tcreate temporary table t\n\t\t( \n\t\t\ttxt text \n\t\t);\n\n\t\tINSERT INTO t values(FilteredManufacturers);\n\n\t\tset @sql1 = concat(\"insert into FilteredManufacturerIds (ManufacturerId) values ('\", replace(( select group_concat(distinct txt) as data from t), \",\", \"'),('\"),\"');\");\n\t\tprepare stmt1 from @sql1;\n\t\texecute stmt1;\n\tend if;\n\n\tSET `ManufacturersCount` = (SELECT COUNT(1) FROM `FilteredManufacturerIds`);\n\n\t#filter by vendor id\n\tcreate temporary table `FilteredVendorIds`\n\t(\n\t\tVendorId int not null\n\t);\n\n\tIF `FilteredVendors` REGEXP '^([[:digit:]](,?))+$' then\n\n\t\tdrop table if exists t;\n\t\tcreate temporary table t\n\t\t( \n\t\t\ttxt text \n\t\t);\n\n\t\tINSERT INTO t values(FilteredVendors);\n        \n\t\tset @sql1 = concat(\"insert into FilteredVendorIds (VendorId) values ('\", replace(( select group_concat(distinct txt) as data from t), \",\", \"'),('\"),\"');\");\n\t\tprepare stmt1 from @sql1;\n\t\texecute stmt1;\n\tend if;\n\n\tSET `VendorsCount` = (SELECT COUNT(1) FROM `FilteredVendorIds`);\n\n    #filter by manufacturer\n\tIF `ManufacturerId` > 0 then\n\t\tSET  @sql_command = concat(@sql_command, '\n\t\t\tAND pmm.ManufacturerId = ', `ManufacturerId`);\n\t\t\n\t\tIF `FeaturedProducts` IS NOT NULL then\n\t\t\tSET  @sql_command = concat(@sql_command, '\n\t\t\t\tAND pmm.IsFeaturedProduct = ', `FeaturedProducts`);\n\t\tEND if;\n\tEND if;\n    \n    #filter by vendor\n\tIF `VendorId` > 0 then\n\t\tSET  @sql_command = concat(@sql_command, '\n\t\tAND p.VendorId = ', `VendorId`);\n\tEND if;\n\n\t#filter by parent grouped product identifer\n\tIF `ParentGroupedProductId` > 0 then\n\t\tSET @sql_command = concat(@sql_command, '\n\t\tAND p.ParentGroupedProductId = ', `ParentGroupedProductId`);\n\tEND if;\n\n\t#filter by on sale\n\tIF `OnSale` then\n\t\tSET  @sql_command = concat(@sql_command, '\n\t\tAND \n\t\t\t(\n\t\t\t\t(cp.`Id` IS NULL AND p.OldPrice > 0  AND p.OldPrice != p.Price)\t\t\t\n\t\t\tOR\t\t\t \n\t\t\t\t(cp.`Id` IS NOT NULL AND cp.`OldPrice` > 0  AND cp.`OldPrice` != cp.`Price`)\n\t\t\t)'\n\t\t);\n\tEND if;\t\n\t\n\t#filter by in stock\n\tIF `InStock` then\n\t\tSET  @sql_command = concat(@sql_command, '\n\t\tAND \n\t\t\t(\n\t\t\t\t(cp.`Id` IS NULL AND \n\t\t\t\t\t(\n\t\t\t\t\t\t(p.ManageInventoryMethodId = 0) OR\n\t\t\t\t\t\t(P.ManageInventoryMethodId = 1 AND\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t(p.StockQuantity > 0 AND p.UseMultipleWarehouses = 0) OR \n\t\t\t\t\t\t\t\t(EXISTS (SELECT 1 FROM ProductWarehouseInventory pwi WHERE pwi.ProductId = p.Id\tAND pwi.StockQuantity > 0 AND pwi.StockQuantity > pwi.ReservedQuantity) AND p.UseMultipleWarehouses = 1)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\tOR\n\t\t\t\t(p.Id IS NOT NULL AND \n\t\t\t\t\t(\n\t\t\t\t\t\t(cp.`ManageInventoryMethodId` = 0) OR\n\t\t\t\t\t\t(cp.`ManageInventoryMethodId` = 1 AND\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t(cp.`StockQuantity` > 0 AND cp.`UseMultipleWarehouses` = 0) OR \n\t\t\t\t\t\t\t\t(EXISTS(SELECT 1 FROM ProductWarehouseInventory pwi WHERE pwi.ProductId = cp.`Id`\tAND pwi.StockQuantity > 0 AND pwi.StockQuantity > pwi.ReservedQuantity) AND cp.`UseMultipleWarehouses` = 1)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t');\n\tend if;\n        \n    #filter by product type\n\tIF `ProductTypeId` is not null then\n\t\tSET  @sql_command = concat(@sql_command, '\n\t\t\tAND p.ProductTypeId = ', `ProductTypeId`);\n\tEND if;\n\t\n\t#filter by visible individually\n\tIF `VisibleIndividuallyOnly` then\n\t\tSET  @sql_command = concat(@sql_command, '\n\t\t\tAND p.VisibleIndividually = 1');\n\tEND if;\n    \n    #filter by product tag\n\tIF COALESCE(`ProductTagId`, 0) != 0 then\n\t\tSET  @sql_command = concat(@sql_command, '\n\t\t\tAND pptm.ProductTag_Id = ', `ProductTagId`);\n\tEND if;\n\t\n\t#show hidden\n\tIF not `ShowHidden` then\n\t\tSET  @sql_command = concat(@sql_command, '\n\t\t\tAND not p.Deleted\n\t\t\tAND p.Published\n\t\t\tAND (utc_date() BETWEEN IFNULL(p.AvailableStartDateTimeUtc, ''1000-01-01'') and IFNULL(p.AvailableEndDateTimeUtc, ''9999-12-31''))');\n\tEND if;\n    \n    #min price\n\tIF `PriceMin` is not null then\n\t\tSET  @sql_command = concat(@sql_command, '\n\t\t\tAND (p.Price >= ', `PriceMin`, ')');\n\tEND if;\n\t\n\t#max price\n\tIF `PriceMax` is not null then\n\t\tSET  @sql_command = concat(@sql_command, '\n\t\tAND (p.Price <= ', `PriceMax`, ')');\n\tEND if;\n    \n    #show hidden and ACL\n\tIF `AllowedCustomerRoleIds` REGEXP '^([[:digit:]](,?))+$' then\n\t\tSET  @sql_command = concat(@sql_command, '\n\t\t\tAND (not p.SubjectToAcl OR EXISTS (\n\t\t\t\t\tSELECT 1 \n\t\t\t\t\tfrom aclRecord as acl \n\t\t\t\t\twhere acl.CustomerRoleId in (', `AllowedCustomerRoleIds` ,') \n\t\t\t\t\t\tand acl.`EntityId` = p.`Id` AND acl.`EntityName` = ''Product''\n\t\t\t\t\t)\n\t\t\t\t)');\n\tEND if;\n\n\t#filter by store\n\tIF `StoreId` > 0 then\n\t\tSET  @sql_command = concat(@sql_command, '\n\t\t\tAND (not p.LimitedToStores OR EXISTS (\n\t\t\t\tSELECT 1 FROM StoreMapping sm\n\t\t\t\tWHERE sm.EntityId = p.Id AND sm.EntityName = ''Product'' and sm.StoreId=', `StoreId`, '\n\t\t\t\t))');\n\tEND if;\n\n\t# We need the selection before the filters are applied because the potential products, which determine the potential\n\t# specification, attribute and manufacturer ids are not going to be in the selection when the filters are applied.\n\tSET @sqlWithoutFilters = @sql_command;\n\t\n\t# filter by SpecificaitonAttributeOptions\n\t# filter only products which does not have a parent (non-child products) or child products\n\t# which are mapped to the category and marked as VisibigleIndividually. The rule that the\n\t# child products are mapped to the category is being applied by the LEFT JOIN with the Product_Category_Mapping table\n\t# and the WHERE clause which restricts the LEFT JOIN to the specified categories\n\tIF `SpecificationAttributesCount` > 0 then\n\t\tSET @sql_command = concat(@sql_command, '\n\t\t\tAND (\n\t\t\t\t(SELECT fsatp.AttributesCount FROM `FilteredSpecificationAttributesToProduct` fsatp\n\t\t\t\tWHERE p.Id = fsatp.ProductId) = ', `SpecificationAttributesCount`, ')');\n    end if;\n\n\t#filter by attributes\n\t#1. We have all the ProductAttributes, which match the selection of the ProductVariantAttributeIds.\n\t#2. We also have the ProductAttributes for the current product, which match the selection of the ProductVariantAttributeIds.\n\t#We select only those products where there are no ProductAttributes from 1. which are not in 2.\n\t#In other words the product should have at least one selected ProductVariantAttributeId in each ProductAttribute.\n\t\n\t#grouped products (ProductTypeId = 10) are being filtered by the attributes of their child products\n\t#normal products are being filtered by their own attributes\n\t\n\tIF `FilteredProductVariantAttributes` REGEXP '^([[:digit:]](,?))+$' then\n\t\tSET @sql_command = concat(@sql_command, '\n\t\t\t\tAND (\n\t\t\t\t\t(SELECT AttributesCount FROM `FilteredProductAttributesToProduct` fpatp\n\t\t\t\t\tWHERE (cp.Id IS NULL AND p.Id = fpatp.ProductId) OR cp.Id = fpatp.ProductId) = ', `ProductAttributesCount`, ')');\n    end if;\n\n\t#filter by manufacturers\n    IF `FilteredManufacturers` REGEXP '^([[:digit:]](,?))+$' then\n\t\tSET @sql_command = concat(@sql_command, '\n\t\t\tAND pmm.ManufacturerId IN (', `FilteredManufacturers`, ')');\t\n    end if;\n\n\t#fiter by vendors\n    IF `FilteredVendors` REGEXP '^([[:digit:]](,?))+$' then\n\t\tSET @sql_command = concat(@sql_command, '\n\t\t\tAND p.VendorId IN (', `FilteredVendors`, ')');\t\n    end if;\n\t\n   \t#sorting\n    SET @sql_orderby = '';\n    \n    CASE `OrderBy` \n\tWHEN 5 THEN Set @sql_orderby = ' p.`Name` ASC'; /* Name: A to Z */\n\tWHEN 6 THEN Set @sql_orderby = ' p.`Name` DESC'; /* Name: Z to A */\n\tWHEN 10 THEN Set @sql_orderby = ' p.`Price` ASC'; /* Price: Low to High */\n\tWHEN 11 THEN Set @sql_orderby = ' p.`Price` DESC'; /* Price: High to Low */\n\tWHEN 15 THEN Set @sql_orderby = ' p.`CreatedOnUtc` DESC'; /* creation date */\n\tELSE /* default sorting, 0 (position) */\n\t\tbegin\n\t\t\tIF `CategoryIds` REGEXP '^([[:digit:]](,?))+$' then \n\t\t\t\tSET @sql_orderby = ' pcm.DisplayOrder ASC';\n\t\t\tend if;\n            \n\t\t\t#manufacturer position (display order)\n\t\t\tIF `ManufacturerId` > 0 then\n\t\t\t\tIF length(@sql_orderby) > 0 then \n\t\t\t\t\tSET @sql_orderby = concat(@sql_orderby, ', ');\n\t\t\t\tend if;\n\t\t\t\tSET @sql_orderby =  concat(@sql_orderby, ' pmm.DisplayOrder ASC');\n\t\t\tEND if;\n\t\t\t\n\t\t\t#name\n\t\t\tIF length(@sql_orderby) > 0 then \n\t\t\t\tSET @sql_orderby = concat(@sql_orderby, ', ');\n\t\t\tend if;\n\t\t\tSET @sql_orderby = concat(@sql_orderby,  ' p.`Name` ASC');\n        end;\n\tend case;\n    \n    SET @sql_command = concat(@sql_command, '\n\tORDER BY', @sql_orderby);\n\t# Build the products without the filters applied. We need to have the product set before the filters are\n\t# applied because from this product set we will calculate the potential products. The potential products\n\t# do not meet the filters in only one filter group but are mapped to an option in this filter group (this option is not selected in the filters).\n\t# These products are potential because when this option is clicked the products will meet the filters. Therefore this option needs\n\t# to reamin available. To calculate which are the potential options we need the potential products. But since these products\n\t# are only potential, they do not meet to selected filters, we need to get the products before the filters are being applied,\n\t# so that we have a product set from which to get the potential products.\n\t\n\tPREPARE sp_executesql FROM @sqlWithoutFilters;\n\tEXECUTE sp_executesql;\n\tDEALLOCATE PREPARE sp_executesql;\n\t            \n\tcreate temporary table `ProductIdsBeforeFiltersApplied`\n\t(\n\t\tProductId int not null,\n\t\tChildProductId int,\n\t\tINDEX(ProductId, ChildProductId)\n\t);\n\n\tINSERT INTO `ProductIdsBeforeFiltersApplied` (`ProductId`, `ChildProductId`)\n\tSELECT ProductId, ChildProductId\n\tFROM `DisplayOrderTmp`\n\tGROUP BY ProductId, ChildProductId\n\tORDER BY min(`Id`);\n\n\t# Delete the products from the #DisplayOrderTmp because this table will used in another call to EXEC sp_executesql @sql\n\t# which will get the products but this time with the filters applied\n\n\tDELETE FROM `DisplayOrderTmp`;\n\n\t# Create the table which will track each product in the result set to how many SpecificationAttributes (specification filter groups) is mapped\n\t# This table will be used to filter the products. If for example we have different SpecificationAttributeOptions selected and these\n\t# SpecificationAttributeOptions are from four different SpecificationAttributes (specification filter groups) selected\n\t# and a product is mapped to exactly four SpecificationAttributes but for the selected SpecificaitonAttributeOptions (filter options)\n\t# then the product meets the specification filters.\n\n\tcreate temporary table `FilteredSpecificationAttributesToProduct`\n\t(\n\t\tProductId int not null,\n\t\tAttributesCount int not null,\n\t\tINDEX(ProductId)\n\t);\n\n\tIF `SpecificationAttributesCount` > 0 then\n\n\t\t# For optimization purposes we need to handle the special case when the selected specification filters are only in one specificaiton attribute.\n\t\t# The INNER JOIN #FilteredSpecificationAttributeOptions will not include\n\t\t# the potential products that is why we need to include them separately. Doing this in one query with a LEFT JOIN is slow.\n\n\t\tIF `SpecificationAttributesCount` > 1 then\n\n\t\t\tINSERT INTO `FilteredSpecificationAttributesToProduct`\n\t\t\tSELECT psm.ProductId, COUNT(DISTINCT `sao`.`SpecificationAttributeId`)\n\t\t\tFROM Product_SpecificationAttribute_Mapping psm\n\t\t\tINNER JOIN `ProductIdsBeforeFiltersApplied` p ON p.ProductId = psm.ProductId\n\t\t\tINNER JOIN `FilteredSpecificationAttributeOptions` fs ON fs.SpecificationAttributeOptionId = psm.SpecificationAttributeOptionId\n\t\t\tINNER JOIN `SpecificationAttributeOption` sao ON sao.Id = psm.SpecificationAttributeOptionId\n\t\t\tGROUP BY psm.ProductId\n\t\t\tHAVING COUNT(DISTINCT `sao`.`SpecificationAttributeId`) >= `SpecificationAttributesCount`;\n\t\tend if;\n\n\t\tIF `SpecificationAttributesCount` = 1 then\n\t\n\t\t\tINSERT INTO `FilteredSpecificationAttributesToProduct`\n\t\t\tSELECT DISTINCT psm.ProductId, 1\n\t\t\tFROM `Product_SpecificationAttribute_Mapping` psm\n\t\t\tINNER JOIN `ProductIdsBeforeFiltersApplied` p ON p.ProductId = psm.ProductId\n\t\t\tINNER JOIN `FilteredSpecificationAttributeOptions` fs ON fs.SpecificationAttributeOptionId = psm.SpecificationAttributeOptionId AND psm.AllowFiltering = 1;\n\t\t\n\t\t\tcreate temporary table `FilteredSpecificationAttributesToProductTmp`\n\t\t\t(\n\t\t\t\tProductId int not null,\n\t\t\t\tAttributesCount int not null,\n\t\t\t\tINDEX(ProductId)\n\t\t\t);\n\n\t\t\tINSERT INTO `FilteredSpecificationAttributesToProductTmp`\n\t\t\tSELECT * FROM `FilteredSpecificationAttributesToProduct`;\n\n\t\t\tINSERT INTO `FilteredSpecificationAttributesToProduct`\n\t\t\tSELECT DISTINCT psm.ProductId, 0\n\t\t\tFROM `Product_SpecificationAttribute_Mapping` psm\n\t\t\tINNER JOIN `ProductIdsBeforeFiltersApplied` p ON p.ProductId = psm.ProductId\n\t\t\tINNER JOIN `SpecificationAttributeOption` sao ON sao.Id = psm.SpecificationAttributeOptionId\n\t\t\tINNER JOIN `FilteredSpecificationAttributes` fsa ON fsa.AttributeId = sao.SpecificationAttributeId\n\t\t\tWHERE NOT EXISTS (SELECT NULL FROM `FilteredSpecificationAttributesToProductTmp` fsatpt WHERE fsatpt.ProductId = psm.ProductId) AND psm.AllowFiltering = 1;\n\t\t\t\n\t\t\tdrop temporary table if exists `FilteredSpecificationAttributesToProductTmp`;\n\t\tend if;\n\n\t\t# Remove all products, which are not mapped to all the selected filter groups.\n\t\t# To be mapped to a selected filter group means that the product has options in this filter group or in other words are not at least potential products.\n\t\t# See more details in the comments about the same delete query in the #FilteredProductAttributesToProduct table.\n\n\t\tIF `SpecificationAttributesCount` > 1 then\n\t\t\n\t\t\tDELETE FROM `FilteredSpecificationAttributesToProduct`\n\t\t\tWHERE (SELECT COUNT(DISTINCT sao.SpecificationAttributeId)\n\t\t\t\t   FROM `Product_SpecificationAttribute_Mapping` psm\n\t\t\t\t   INNER JOIN `SpecificationAttributeOption` sao ON sao.Id = psm.SpecificationAttributeOptionId\n\t\t\t\t   INNER JOIN `FilteredSpecificationAttributes` fsa ON fsa.AttributeId = sao.SpecificationAttributeId\n\t\t\t\t   WHERE psm.ProductId = `FilteredSpecificationAttributesToProduct`.ProductId) < `SpecificationAttributesCount`;\n\t\tend if;\n\tend if;\n\n\t# Create the table which will track each product in the result set to how many ProductAttributes (attribute filter groups) is mapped\n\t# This table will be used to filter the products. If for example we have different ProductAttributeValues selected and these\n\t# ProductAttributeValues are from four different ProductAttributes (attribute filter groups) selected\n\t# and a product is mapped to exactly four ProductAttribute but for the selected ProductAttributeValues (product filter options)\n\t# then the product meets the product attribute filters.\n\t# It is important to note that the selected ids passed in the @FilterableProductVariantAttributeIds parameter of the store procedure are actually\n\t# the ids of the mapping between the products and the product attributes (Product_ProductAttribute_Mapping) and not actually the ids of the ProductAttributeValues.\n\n\tcreate temporary table `FilteredProductAttributesToProduct`\n\t(\n\t\tProductId int not null,\n\t\tAttributesCount int not null,\n\t\tINDEX(ProductId)\n\t);\n\n\t# Insert only the products which meet the attribute filters or are potential products.\n\t# For a product to meeet the filters, it needs to have meet the filters in all the seleted filter groups.\n\t# For a product to be a potential product it needs to meet the filters in all but one filter groups.\n\n\tIF `ProductAttributesCount` > 0 then\n\t\t# For optimization purposes we need to handle the special case when the selected attribute filters are only in one product attribute.\n\t\t# The INNER JOIN #FilteredSpecificationAttributeOptions will not include\n\t\t# the potential products that is why we need to include them separately. Doing this in one query with a LEFT JOIN is slow.\n\n\t\tIF `ProductAttributesCount` > 1 then\n\t\t\tINSERT INTO `FilteredProductAttributesToProduct`\n\t\t\tSELECT ppm.ProductId, COUNT(DISTINCT ppm.ProductAttributeId)\n\t\t\tFROM Product_ProductAttribute_Mapping ppm\n\t\t\tINNER JOIN `ProductIdsBeforeFiltersApplied` p ON p.ProductId = ppm.ProductId OR p.ChildProductId = ppm.ProductId\n\t\t\tINNER JOIN `FilteredProductVariantAttributeIds` fpva ON fpva.ProductVariantAttributeId = ppm.Id\n\t\t\tGROUP BY ppm.ProductId\n\t\t\tHAVING COUNT(DISTINCT ppm.ProductAttributeId) >= `ProductAttributesCount` - 1;\n\t\tend if;\n\t\t\n\t\tIF `ProductAttributesCount` = 1 then\n\t\t\tINSERT INTO `FilteredProductAttributesToProduct`\n\t\t\tSELECT DISTINCT ppm.ProductId, 1\n\t\t\tFROM Product_ProductAttribute_Mapping ppm\n\t\t\tINNER JOIN `ProductIdsBeforeFiltersApplied` p ON p.ProductId = ppm.ProductId OR p.ChildProductId = ppm.ProductId\n\t\t\tINNER JOIN `FilteredProductVariantAttributeIds` fpva ON fpva.ProductVariantAttributeId = ppm.Id;\n\t\t\n\t\t\tcreate temporary table `FilteredProductAttributesToProductTmp`\n\t\t\t(\n\t\t\t\tProductId int not null,\n\t\t\t\tAttributesCount int not null,\n\t\t\t\tINDEX(ProductId)\n\t\t\t);\n\n\t\t\tINSERT INTO `FilteredProductAttributesToProductTmp`\n\t\t\tSELECT * FROM `FilteredProductAttributesToProduct`;\n\n\t\t\tINSERT INTO `FilteredProductAttributesToProduct`\n\t\t\tSELECT DISTINCT ppm.ProductId, 0\n\t\t\tFROM Product_ProductAttribute_Mapping ppm\n\t\t\tINNER JOIN `ProductIdsBeforeFiltersApplied` p ON p.ProductId = ppm.ProductId OR p.ChildProductId = ppm.ProductId\n\t\t\tINNER JOIN `FilteredProductAttributes` fa ON fa.AttributeId = ppm.ProductAttributeId\n\t\t\tWHERE ppm.ProductId NOT IN (SELECT ProductId FROM `FilteredProductAttributesToProductTmp`);\n\n\t\t\tdrop temporary table if exists `FilteredProductAttributesToProductTmp`;\n\t\tend if;\n\n\t\t# Remove all products, which are not mapped to all the selected filter groups.\n\t\t# To be mapped to a selected filter group means that the product has options in this filter group.\n\t\t# But these options do not need to be amongst the selected filter options. This query in reality removes\n\t\t# all the products that are not pontetial products. Such products are in the result set of the #FilteredProductAttributesToProduct\n\t\t# because although the previuos query inserted only products which meet the filters in all groups or in all but one,\n\t\t# there could be such products that meet the filters in all but one group but do not have any options in the remaining group.\n\t\t\n\t\t# For example we have the following Attributes: Color (Blue, Green, Red), Size (M, L, XL), Style (Slim, Straight, Skater) and the follwing attribute filters are selected: \n\t\t# Color: Blue, Size: XL, Style: Slim. For a product to meet the filters it needs to have at least Color: Blue, Size: XL and Style: Slim.\n\t\t# For a product to be potential it needs to have at least two of the three selected attributes and have a potential option in the third.\n\t\t# For example a product that has Color: Green, Size, XL and Style: Slim is a potential one because it does not meet the filters in only one filter group\n\t\t# Color, but has an option in this group Green, although this option is not selected. The products which meet the filters or are pontential ones\n\t\t# are used to determine the available filter options. Because the product is a potential one the option Green should remain available.\n\t\t\n\t\t# Here we delete all the potnetial products from the #FilteredProductAttributesToProduct who meet the filter groups in all but one group\n\t\t# but do not have an option at all in the group which they do not meet. So if our product did not have Color at all\n\t\t# it would not be a potential one and will be removed from the #FilteredProductAttributesToProduct table.\n\n\t\tIF `ProductAttributesCount` > 1 then\n\t\t\tDELETE FROM `FilteredProductAttributesToProduct`\n\t\t\tWHERE (SELECT COUNT(DISTINCT ppm.ProductAttributeId) FROM\n\t\t\tProduct_ProductAttribute_Mapping ppm\n\t\t\tINNER JOIN `FilteredProductAttributes` fa ON fa.AttributeId = ppm.ProductAttributeId\n\t\t\tWHERE ppm.ProductId = `FilteredProductAttributesToProduct`.ProductId) < `ProductAttributesCount`;\n\t\tend if;\n\tend if;   \n\n    PREPARE sql_do_stmts FROM @sql_command;\n\tEXECUTE sql_do_stmts;\n\tDEALLOCATE PREPARE sql_do_stmts;\n\n    select count(Id) from `DisplayOrderTmp` into `TotalRecords`;\n\n\t# Determine the available specification, attribute, manufacturer and vendor options.\n\tIF `LoadAvailableFilters` then\n\t\n\t\tcreate temporary table `PotentialProductSpecificationAttributeIds`\n\t\t(\n\t\t\t`ProductId` int NOT NULL,\n\t\t\t`SpecificationAttributeOptionId` int NOT NULL\n\t\t);\n\t\t\n\t\t# Build the potential products for the selected specificaiton attributes options.\n\t\t# The potential products meet the specificaiton filters in all but one of the selected specification filter groups.\n\t\t# The potential products need to be selected only with their SpecificationAttributeOptions which are in\n\t\t# the SpecificationAttribute for which they do not meet the filters\n\t\tINSERT INTO `PotentialProductSpecificationAttributeIds` (`ProductId`, `SpecificationAttributeOptionId`)\n\t\tSELECT psm.ProductId, psm.SpecificationAttributeOptionId\n\t\tFROM `Product_SpecificationAttribute_Mapping` psm\n\t\tINNER JOIN `FilteredSpecificationAttributesToProduct` fsatp on fsatp.ProductId = psm.ProductId\n\t\tINNER JOIN `SpecificationAttributeOption` sao ON sao.Id = psm.SpecificationAttributeOptionId\n\t\tINNER JOIN `FilteredSpecificationAttributes` fsa ON fsa.AttributeId = sao.SpecificationAttributeId\n\t\tWHERE fsatp.AttributesCount = `SpecificationAttributesCount` - 1 AND\n\t\tsao.SpecificationAttributeId NOT IN \n\t\t(SELECT sao.SpecificationAttributeId FROM Product_SpecificationAttribute_Mapping psm1\n\t\tINNER JOIN `SpecificationAttributeOption` sao1 ON sao1.Id = psm1.SpecificationAttributeOptionId\n\t\tINNER JOIN `FilteredSpecificationAttributeOptions` fs ON fs.SpecificationAttributeOptionId = sao1.Id\n\t\tWHERE psm1.ProductId = psm.ProductId);\n\t\t\n\t\t# Delete all the #PotentialProductSpecificationAttributeIds, which do not match the attribute filters\n\t\tIF `ProductAttributesCount` > 0 then\n\t\t\t#Query is devided to prevent can't reopen FilteredSpecificationAttributesToProduct table exception.\n\t\t\t#The performance should be tested\n\t\t\tDELETE ppsa\n\t\t\tFROM `PotentialProductSpecificationAttributeIds` ppsa\n\t\t\tINNER JOIN `ProductIdsBeforeFiltersApplied` pibfa ON pibfa.ProductId = ppsa.ProductId\n\t\t\tWHERE \n\t\t\t(\n\t\t\t\tpibfa.ChildProductId = 0 AND\n\t\t\t\t(\n\t\t\t\t\tNOT EXISTS (SELECT NULL FROM `FilteredProductAttributesToProduct` WHERE ProductId = pibfa.ProductId)\t\t\t\t\t\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tDELETE ppsa\n\t\t\tFROM `PotentialProductSpecificationAttributeIds` ppsa\n\t\t\tINNER JOIN `ProductIdsBeforeFiltersApplied` pibfa ON pibfa.ProductId = ppsa.ProductId\n\t\t\tWHERE \n\t\t\t(\n\t\t\t\tpibfa.ChildProductId = 0 AND\n\t\t\t\t(\n\t\t\t\t\t(SELECT AttributesCount FROM `FilteredProductAttributesToProduct` WHERE ProductId = pibfa.ProductId) != `ProductAttributesCount`\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tDELETE ppsa\n\t\t\tFROM `PotentialProductSpecificationAttributeIds` ppsa\n\t\t\tINNER JOIN `ProductIdsBeforeFiltersApplied` pibfa ON pibfa.ProductId = ppsa.ProductId\n\t\t\tWHERE \n\t\t\t(\n\t\t\t\tpibfa.ChildProductId != 0 AND\n\t\t\t\t(\n\t\t\t\t\tNOT EXISTS (SELECT NULL FROM `FilteredProductAttributesToProduct` WHERE ProductId = pibfa.ChildProductId)\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tDELETE ppsa\n\t\t\tFROM `PotentialProductSpecificationAttributeIds` ppsa\n\t\t\tINNER JOIN `ProductIdsBeforeFiltersApplied` pibfa ON pibfa.ProductId = ppsa.ProductId\n\t\t\tWHERE \n\t\t\t(\n\t\t\t\tpibfa.ChildProductId != 0 AND\n\t\t\t\t(\n\t\t\t\t\t(SELECT AttributesCount FROM `FilteredProductAttributesToProduct` WHERE ProductId = pibfa.ChildProductId) != `ProductAttributesCount`\n\t\t\t\t)\n\t\t\t);\n\t\tend if;\n\t\t\n\t\t#Delete all the #PotentialProductSpecificationAttributeIds, which do not match the manufacturer filters\n\t\tIF `ManufacturersCount` > 0 then\n\t\t\tDELETE FROM `PotentialProductSpecificationAttributeIds`\n\t\t\tWHERE NOT EXISTS (\n\t\t\t\tSELECT NULL FROM Product_Manufacturer_Mapping pmm\n\t\t\t\tINNER JOIN `FilteredManufacturerIds` fm ON fm.ManufacturerId = pmm.ManufacturerId\n\t\t\t\tWHERE pmm.ProductId = `PotentialProductSpecificationAttributeIds`.`ProductId`);\n\t\tend if;\n\t\t\n\t\t#Delete all the #PotentialProductSpecificationAttributeIds, which do not match the vendor filters\n\t\tIF `VendorsCount` > 0 then\n\t\t\tDELETE FROM `PotentialProductSpecificationAttributeIds`\n\t\t\tWHERE NOT EXISTS (\n\t\t\t\tSELECT NULL FROM Product p\n\t\t\t\tINNER JOIN `FilteredVendorIds` fv ON fv.VendorId = p.VendorId\n\t\t\t\tWHERE p.Id = `PotentialProductSpecificationAttributeIds`.`ProductId`);\n\t\tend if;\t\t\n\t\t\n\t\t#build the available SpecificationAttributeOptionIds\n\t\t\n\t\tcreate temporary table `FilterableSpecs`\n\t\t(\n\t\t\t`ProductId` int NOT NULL,\n\t\t\t`SpecificationAttributeOptionId` int NOT NULL\n\t\t);\n\t\t\n\t\tcreate temporary table `FilterableSpecsDistinct`\n\t\t(\n\t\t\t`SpecificationAttributeOptionId` int NOT NULL\n\t\t);\n\t\t\n\t\t#insert all the SpecificationAttributeOptionIds from the filtered products, as these SpecificationAttributeOptionIds\n\t\t#should be avaialble\n\t\tINSERT INTO `FilterableSpecs` (`ProductId`, `SpecificationAttributeOptionId`)\n\t\tSELECT DISTINCT psam.ProductId, psam.SpecificationAttributeOptionId\n\t\tFROM Product_SpecificationAttribute_Mapping psam\n\t\tWHERE psam.ProductId IN (SELECT dop.ProductId FROM `DisplayOrderTmp` dop) AND psam.AllowFiltering = 1;\n\t\t\n\t\t#insert all the SpecificationAttributeOptioinIds from the potential products, where there is only one potential\n\t\t#SpecificationAttribute for a product. This means that SepcificationAttributeOptions for the potential product\n\t\t#are available only if the pontetial products has pontetial SpecificationAttributeOptions in one SpecificationAttribute,\n\t\t#it does not meet the criteria of one SpecificationAttribute but has potential SpecificationAttributeOptions in it. If\n\t\t#it has potential SpecificationAttributeOptions in more than one SpecificationAttribute than it does not meet the selected\n\t\t#SpecificationAttributeOptions of at least two SpecificationAttributes, which means that there are not potential\n\t\t#SpecificationAttributeOptions for the product.\n\t\t\n\t\tINSERT INTO `FilterableSpecs` (ProductId, SpecificationAttributeOptionId)\n\t\tSELECT DISTINCT ProductId, SpecificationAttributeOptionId\n\t\tFROM `PotentialProductSpecificationAttributeIds`;\n\t\t\n\t\tINSERT INTO `FilterableSpecsDistinct` (SpecificationAttributeOptionId)\n\t\tSELECT DISTINCT SpecificationAttributeOptionId\n\t\tFROM `FilterableSpecs`;\n\n\t\t#build comma separated list of filterable identifiers\n\t\tSELECT GROUP_CONCAT(SpecificationAttributeOptionId) FROM `FilterableSpecsDistinct` into `FilterableSpecificationAttributeOptionIds`;\n\t\t\n\t\t#build the available ProductVariantAttributeIds\n\t\t\n\t\tcreate temporary table `PotentialProductVariantAttributeIds` \n\t\t(\n\t\t\t`ProductId` int NOT NULL,\n\t\t\t`ProductVariantAttributeId` int NOT NULL,\n\t\t\tINDEX(ProductId)\n\t\t);\n\t\t\n\t\t# Build the #PotentialProductVariantAttributeIds. The potential products are the ones that meet the filters in all the filter groups but one.\n\t\t# We need to bear in mind that the there is only one ProductVariantAttributeId for the mapping between a product and and a ProductAttribute\n\t\t# regardless of the value of the ProductAttribute. So for example if a product is mapped to a ProductAttrbiute Color with the values Blue and Green\n\t\t# its ProductVariantAttributeId will be the same for both the Blue and Green attribute values. The ProductVariantAttributeIds represent\n\t\t# the selected attribute filter options.\n\n\t\tINSERT INTO `PotentialProductVariantAttributeIds` (ProductId, ProductVariantAttributeId)\n\t\tSELECT ppm.ProductId, ppm.Id\n\t\tFROM Product_ProductAttribute_Mapping ppm\n\t\tINNER JOIN `FilteredProductAttributesToProduct` fpatp ON fpatp.ProductId = ppm.ProductId\n\t\tINNER JOIN `FilteredProductAttributes` fa ON fa.AttributeId = ppm.ProductAttributeId\n\t\tWHERE fpatp.AttributesCount = `ProductAttributesCount` - 1 AND \n\t\tppm.Id NOT IN (SELECT ProductVariantAttributeId FROM `FilteredProductVariantAttributeIds`);\n\n\t\t# Delete all the #PotentialProductVariantAttributeIds, which do not match the specification attribute filters\n\t\t# both the parent and child products attribute filters are being used\n\t\tIF `SpecificationAttributesCount` > 0 then\n\t\t\t#Query is devided to prevent can't reopen FilteredSpecificationAttributesToProduct table exception.\n\t\t\tDELETE `PotentialProductVariantAttributeIds`\n\t\t\tFROM `PotentialProductVariantAttributeIds`\n\t\t\tINNER JOIN `ProductIdsBeforeFiltersApplied` pibfa ON pibfa.ProductId = `PotentialProductVariantAttributeIds`.`ProductId` OR pibfa.ChildProductId = `PotentialProductVariantAttributeIds`.`ProductId`\n\t\t\tWHERE \n\t\t\t(\n\t\t\t\tNOT EXISTS (SELECT NULL FROM `FilteredSpecificationAttributesToProduct` WHERE ProductId = pibfa.ProductId)\n\t\t\t);\n\n\t\t\tDELETE `PotentialProductVariantAttributeIds`\n\t\t\tFROM `PotentialProductVariantAttributeIds`\n\t\t\tINNER JOIN `ProductIdsBeforeFiltersApplied` pibfa ON pibfa.ProductId = `PotentialProductVariantAttributeIds`.`ProductId` OR pibfa.ChildProductId = `PotentialProductVariantAttributeIds`.`ProductId`\n\t\t\tWHERE \n\t\t\t(\n\t\t\t\t(SELECT AttributesCount FROM `FilteredSpecificationAttributesToProduct` WHERE ProductId = pibfa.ProductId) != `SpecificationAttributesCount`\n\t\t\t);\n\t\tend if;\n\t\t\n\t\t#Delete all the #PotentialProductVariantAttributeIds, which do not match the manufacturer filters.\n\t\tIF `ManufacturersCount` > 0 then\n\t\t\tDELETE FROM `PotentialProductVariantAttributeIds`\n\t\t\tWHERE NOT EXISTS (\n\t\t\t\tSELECT NULL FROM Product_Manufacturer_Mapping pmm\n\t\t\t\tINNER JOIN `FilteredManufacturerIds` fm ON fm.ManufacturerId = pmm.ManufacturerId\n\t\t\t\tINNER JOIN `ProductIdsBeforeFiltersApplied` pibfa ON pibfa.ProductId = pmm.ProductId\n\t\t\t\tWHERE `PotentialProductVariantAttributeIds`.`ProductId` = pibfa.ProductId OR `PotentialProductVariantAttributeIds`.`ProductId` = pibfa.ChildProductId);\n\t\tend if;\n\t\t\n\t\t#Delete all the #PotentialProductVariantAttributeIds, which do not match the vendor filters\n\t\t# both the parent and child products attribute filters are being used\n\t\tIF `VendorsCount` > 0 then\n\t\t\tDELETE FROM `PotentialProductVariantAttributeIds`\n\t\t\tWHERE NOT EXISTS (\n\t\t\t\tSELECT NULL FROM Product p\n\t\t\t\tINNER JOIN `FilteredVendorIds` fv ON fv.VendorId = p.VendorId\n\t\t\t\tINNER JOIN `ProductIdsBeforeFiltersApplied` pibfa ON pibfa.ProductId = p.Id\n\t\t\t\tWHERE `PotentialProductVariantAttributeIds`.`ProductId` = pibfa.ProductId OR `PotentialProductVariantAttributeIds`.`ProductId` = pibfa.ChildProductId);\n\t\tend if;\n\t\t\n\t\tcreate temporary table `FilterableProductVariantIds`\n\t\t(\n\t\t\tProductId int NOT NULL,\n\t\t\tProductVariantAttributeId int NOT NULL\n\t\t);\n\t\t\n\t\tcreate temporary table `FilterableProductVariantIdsDistinct` \n\t\t(\n\t\t\tProductVariantAttributeId int NOT NULL\n\t\t);\n\t\t\n\t\t#insert all the ProductVariantAttributeIds from the filtered products, as these ProductVariantAttributeIds\n\t\t#should be available\n\t\tINSERT INTO `FilterableProductVariantIds` (ProductId, ProductVariantAttributeId)\n\t\tSELECT DISTINCT ppm.ProductId, ppm.Id\n\t\tFROM Product_ProductAttribute_Mapping ppm\n\t\tINNER JOIN `DisplayOrderTmp` dot ON dot.ProductId = ppm.ProductId OR dot.ChildProductId = ppm.ProductId;\n\t\t\n\t\t#insert the #PotentialProductVariantAttributeIds\n\t\tINSERT INTO `FilterableProductVariantIds` (ProductId, ProductVariantAttributeId)\n\t\tSELECT DISTINCT ProductId, ProductVariantAttributeId\n\t\tFROM `PotentialProductVariantAttributeIds`;\n\t\t\n\t\tINSERT INTO `FilterableProductVariantIdsDistinct` (ProductVariantAttributeId)\n\t\tSELECT DISTINCT ProductVariantAttributeId\n\t\tFROM `FilterableProductVariantIds`;\n\t\t\n\t\t#build comma separated list of filterable identifiers\n\t\tSELECT GROUP_CONCAT(ProductVariantAttributeId) FROM `FilterableProductVariantIdsDistinct` into `FilterableProductVariantAttributeIds`;\n\t\t\t\t\n\t\t#build the available ManufacturerIds\n\t\t\n\t\tcreate temporary table `FilterableManufacturers`\n\t\t(\n\t\t\t`ProductId` int NOT NULL,\n\t\t\t`ManufacturerId` int NOT NULL\n\t\t);\n\t\t\n\t\t# insert all the ManufacturerIds from the filtered products, as these ManufacturerIds\n\t\t# should be avaialble\n\t\tINSERT INTO `FilterableManufacturers` (ProductId, ManufacturerId)\n\t\tSELECT DISTINCT pmm.ProductId, pmm.ManufacturerId\n\t\tFROM Product_Manufacturer_Mapping pmm\n\t\tINNER JOIN `ProductIdsBeforeFiltersApplied` ON `ProductIdsBeforeFiltersApplied`.`ProductId` = pmm.ProductId;\n\t\t\n\t\t# Delete all the #FilterableManufacturers, which do not match the specification attribute filters\n\t\tIF `SpecificationAttributesCount` > 0 then\t\t\n\t\t\tDELETE fm\n\t\t\tFROM `FilterableManufacturers` fm\n\t\t\tLEFT JOIN `FilteredSpecificationAttributesToProduct` fsatp ON fsatp.ProductId = fm.ProductId\n\t\t\tWHERE fsatp.ProductId IS NULL OR fsatp.AttributesCount != `SpecificationAttributesCount`;\t\t\t\n\t\tend if;\n\t\t\n\t\t# Delete all the #FilterableManufacturers, which do not match the attribute filters.\n\t\tIF `ProductAttributesCount` > 0 then\n\t\t\t#Query is devided to prevent can't reopen FilteredSpecificationAttributesToProduct table exception.\n\t\t\t#The performance should be tested\n\t\t\tDELETE fm\n\t\t\tFROM `FilterableManufacturers` fm\n\t\t\tINNER JOIN `ProductIdsBeforeFiltersApplied` pibfa ON pibfa.ProductId = fm.ProductId\n\t\t\tWHERE \n\t\t\t(\n\t\t\t\tpibfa.ChildProductId = 0 AND\n\t\t\t\t(\n\t\t\t\t\tNOT EXISTS (SELECT NULL FROM `FilteredProductAttributesToProduct` WHERE ProductId = pibfa.ProductId)\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tDELETE fm\n\t\t\tFROM `FilterableManufacturers` fm\n\t\t\tINNER JOIN `ProductIdsBeforeFiltersApplied` pibfa ON pibfa.ProductId = fm.ProductId\n\t\t\tWHERE \n\t\t\t(\n\t\t\t\tpibfa.ChildProductId = 0 AND\n\t\t\t\t(\n\t\t\t\t\t(SELECT AttributesCount FROM `FilteredProductAttributesToProduct` WHERE ProductId = pibfa.ProductId) != `ProductAttributesCount`\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tDELETE fm\n\t\t\tFROM `FilterableManufacturers` fm\n\t\t\tINNER JOIN `ProductIdsBeforeFiltersApplied` pibfa ON pibfa.ProductId = fm.ProductId\n\t\t\tWHERE \n\t\t\t(\n\t\t\t\tpibfa.ChildProductId != 0 AND\n\t\t\t\t(\n\t\t\t\t\tNOT EXISTS (SELECT NULL FROM `FilteredProductAttributesToProduct` WHERE ProductId = pibfa.ChildProductId)\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tDELETE fm\n\t\t\tFROM `FilterableManufacturers` fm\n\t\t\tINNER JOIN `ProductIdsBeforeFiltersApplied` pibfa ON pibfa.ProductId = fm.ProductId\n\t\t\tWHERE \n\t\t\t(\n\t\t\t\tpibfa.ChildProductId != 0 AND\n\t\t\t\t(\n\t\t\t\t\t(SELECT AttributesCount FROM `FilteredProductAttributesToProduct` WHERE ProductId = pibfa.ChildProductId) != `ProductAttributesCount`\n\t\t\t\t)\n\t\t\t);\n\t\tend if;\n        \n\t\t# Delete all the #FilterableManufacturers, which do not match the vendor filters\n\t\tIF `VendorsCount` > 0 then\t\t\n\t\t\tDELETE FROM `FilterableManufacturers`\n\t\t\tWHERE NOT EXISTS\n\t\t\t(\n\t\t\t\tSELECT NULL FROM Product p\n\t\t\t\tINNER JOIN `FilteredVendorIds` fv ON fv.VendorId = p.VendorId\n\t\t\t\tWHERE p.Id = `FilterableManufacturers`.`ProductId`\n\t\t\t);\n\t\tend if;\n        \n\t\t# build comma separated list of filterable identifiers\t\t\n\t\tSET `FilterableManufacturerIds` = (SELECT group_concat(DISTINCT fm.ManufacturerId)  FROM `FilterableManufacturers` fm);\n\n\t\t# build the available VendorIds\n\t\tcreate temporary table `FilterableVendors`\n\t\t(\n\t\t\t`ProductId` int NOT NULL,\n\t\t\t`VendorId` int NOT NULL\n\t\t);\n\t\t\n\t\t# insert all the VendorIds from the filtered products, as these VendorIds\n\t\t# should be avaialble\n\t\tINSERT INTO `FilterableVendors` (ProductId, VendorId)\n\t\tSELECT DISTINCT pv.Id, pv.VendorId\n\t\tFROM Product pv\n\t\tINNER JOIN `ProductIdsBeforeFiltersApplied` ON `ProductIdsBeforeFiltersApplied`.`ProductId` = pv.Id;\n\n\t\t# Delete all the `FilterableVendors`, which do not match the specification attribute filters\n\t\tIF `SpecificationAttributesCount` > 0 then\n\t\t\tDELETE fv\n\t\t\tFROM `FilterableVendors` fv\n\t\t\tLEFT JOIN `FilteredSpecificationAttributesToProduct` fsatp ON fsatp.ProductId = fv.ProductId\n\t\t\tWHERE fsatp.ProductId IS NULL OR fsatp.AttributesCount != `SpecificationAttributesCount`;\n\t\tend if;\n\t\t\n\t\t# Delete all the #FilterableVendors, which do not match the attribute filters\n\t\t# Delete all the products, where there is a selected attribute option (mapping between a product and the attribute)\n\t\t# and there is no attribute mapping between the product and the attribute of the selected attribute option.\n\t\t# Both the parent and child products attribute filters are being used.\n\t\tIF `ProductAttributesCount` > 0 then\n\t\t\t#Query is devided to prevent can't reopen FilteredSpecificationAttributesToProduct table exception.\n\t\t\t#The performance should be tested\n\t\t\tDELETE fv\n\t\t\tFROM `FilterableVendors` fv\n\t\t\tINNER JOIN `ProductIdsBeforeFiltersApplied` pibfa ON pibfa.ProductId = fv.ProductId\n\t\t\tWHERE \n\t\t\t(\n\t\t\t\tpibfa.ChildProductId = 0 AND\n\t\t\t\t(\n\t\t\t\t\tNOT EXISTS (SELECT NULL FROM `FilteredProductAttributesToProduct` WHERE ProductId = pibfa.ProductId)\n\t\t\t\t)\n\t\t\t);\t\t\n\n\t\t\tDELETE fv\n\t\t\tFROM `FilterableVendors` fv\n\t\t\tINNER JOIN `ProductIdsBeforeFiltersApplied` pibfa ON pibfa.ProductId = fv.ProductId\n\t\t\tWHERE \n\t\t\t(\n\t\t\t\tpibfa.ChildProductId = 0 AND\n\t\t\t\t(\n\t\t\t\t\t(SELECT AttributesCount FROM `FilteredProductAttributesToProduct` WHERE ProductId = pibfa.ProductId) != `ProductAttributesCount`\n\t\t\t\t)\n\t\t\t);\t\n\n\t\t\tDELETE fv\n\t\t\tFROM `FilterableVendors` fv\n\t\t\tINNER JOIN `ProductIdsBeforeFiltersApplied` pibfa ON pibfa.ProductId = fv.ProductId\n\t\t\tWHERE \n\t\t\t(\n\t\t\t\tpibfa.ChildProductId != 0 AND\n\t\t\t\t(\n\t\t\t\t\tNOT EXISTS (SELECT NULL FROM `FilteredProductAttributesToProduct` WHERE ProductId = pibfa.ChildProductId)\n\t\t\t\t)\n\t\t\t);\t\n\n\t\t\tDELETE fv\n\t\t\tFROM `FilterableVendors` fv\n\t\t\tINNER JOIN `ProductIdsBeforeFiltersApplied` pibfa ON pibfa.ProductId = fv.ProductId\n\t\t\tWHERE \n\t\t\t(\n\t\t\t\tpibfa.ChildProductId != 0 AND\n\t\t\t\t(\n\t\t\t\t\t(SELECT AttributesCount FROM `FilteredProductAttributesToProduct` WHERE ProductId = pibfa.ChildProductId) != `ProductAttributesCount`\n\t\t\t\t)\n\t\t\t);\t\n\t\tend if;\n\t\t\n\t\t# Delete all the #FilterableVendors, which do not match the manufacturer filters\n\t\tIF `ManufacturersCount` > 0 then\t\t\n\t\t\tDELETE FROM `FilterableVendors`\n\t\t\tWHERE NOT EXISTS\n\t\t\t(\n\t\t\t\tSELECT NULL FROM Product_Manufacturer_Mapping pmm\n\t\t\t\tINNER JOIN `FilteredManufacturerIds` fm ON fm.ManufacturerId = pmm.ManufacturerId\n\t\t\t\tWHERE pmm.ProductId = `FilterableVendors`.`ProductId`\n\t\t\t);\n\t\tend if;\n\n\t\t# build comma separated list of filterable identifiers\n\t\tSET `FilterableVendorIds` = (SELECT group_concat(DISTINCT fv.VendorId)  FROM `FilterableVendors` fv);\n \tend if;\n\n\tcreate temporary table `KeepRows`\n\t(\n\t\tRowId int,\n\t\tProductId int\n\t);\n\n\tINSERT INTO `KeepRows`\n\tSELECT MIN(Id) as RowId, ProductId\n\tFROM `DisplayOrderTmp`\n\tGROUP BY ProductId;\n\n \t# delete the duplicate product rows which were added as a result of the LEFT JOIN with the child products\n\tDELETE dot\n\tFROM `DisplayOrderTmp` dot\n\t\tLEFT OUTER JOIN `KeepRows` ON dot.Id = KeepRows.RowId\n\tWHERE\n\t\tKeepRows.RowId IS NULL;\n\n\tselect count(Id) from `DisplayOrderTmp` into `TotalRecords`;\n\n\t# rebuild the product result table so that the paging will work correctly\n \t# the paging is based on the IndexId identity column, which is auto inremented by 1.\n \t# if we delete from the table then the IndexId would not correspond to the number of products.\n \t# this is why we need to rebuild the table.\n \t\n\tcreate temporary table `DisplayOrderTmpDistinct`\n\t(\n\t\t`Id` int NOT NULL auto_increment,\n\t\t`ProductId` int NOT NULL,\n\t\t PRIMARY KEY (Id)\n\t);\n\n\tINSERT INTO `DisplayOrderTmpDistinct` (ProductId)\n\tSELECT ProductId\n\tFROM `DisplayOrderTmp`\t\n\tORDER BY Id;\n\n\tIF `IsOnSaleFilterEnabled` then\n\t\t#check if there are products on sale\n\t\tIF EXISTS (SELECT NULL FROM Product p \n\t\t\t\t  LEFT JOIN Product AS cp ON p.Id = cp.ParentGroupedProductId \n\t\t\t\t  INNER JOIN `DisplayOrderTmpDistinct` pid ON pid.ProductId = p.Id\n\t\t\t\t  WHERE (\n\t\t\t\t\t\t\t(cp.`Id` IS NULL AND p.OldPrice > 0 AND p.Price != p.OldPrice)\n\t\t\t\t\t\t\tOR\n\t\t\t\t\t\t\t(cp.`Id` IS NOT NULL AND cp.`OldPrice` > 0 AND cp.`OldPrice` != cp.`Price`)\n\t\t\t\t\t\t) \n\t\t\t\t  )\n\t\t\tthen\n\t\t\t\tSET `HasProductsOnSale` = true;\n\t\t\tend if;\n\t\tELSE\n\t\t\tSET `HasProductsOnSale` = false;\n\tend if;\n\n\tIF `IsInStockFilterEnabled` then\n\t#check if there are products in stock\n\t\tIF EXISTS (SELECT NULL FROM Product p \n\t\t\t\tLEFT JOIN Product AS cp ON p.Id = cp.ParentGroupedProductId \n\t\t\t\tINNER JOIN `DisplayOrderTmpDistinct` pid ON pid.ProductId = p.Id\n\t\t\t\tWHERE (\n\t\t\t\t\t\t(cp.`Id` IS NULL  AND \n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t(p.ManageInventoryMethodId = 0) OR\n\t\t\t\t\t\t\t\t\t(P.ManageInventoryMethodId = 1 AND\n\t\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t\t(p.StockQuantity > 0 AND p.UseMultipleWarehouses = 0) OR \n\t\t\t\t\t\t\t\t\t\t(EXISTS(SELECT 1 FROM ProductWarehouseInventory pwi WHERE\tpwi.ProductId = p.Id\tAND pwi.StockQuantity > 0 AND pwi.StockQuantity > pwi.ReservedQuantity) AND p.UseMultipleWarehouses = 1)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t\tOR\n\t\t\t\t\t\t(p.Id IS NOT NULL AND \n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t(cp.`ManageInventoryMethodId` = 0) OR\n\t\t\t\t\t\t\t\t(cp.`ManageInventoryMethodId` = 1 AND\n\t\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t\t(cp.`StockQuantity` > 0 AND cp.`UseMultipleWarehouses` = 0) OR \n\t\t\t\t\t\t\t\t\t\t(EXISTS(SELECT 1 FROM ProductWarehouseInventory pwi WHERE pwi.ProductId = cp.`Id`\tAND pwi.StockQuantity > 0 AND pwi.StockQuantity > pwi.ReservedQuantity) AND cp.`UseMultipleWarehouses` = 1)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\tthen\n\t\t\tSET `HasProductsInStock` = true;\n\t\telse\n\t\t\tSET `HasProductsInStock` = false;\n\t\tend if;\n\tend if;\n\n\t#return products\n\tSELECT p.*\n\tFROM `DisplayOrderTmpDistinct` dotd\n\t\tINNER JOIN Product p on p.Id = dotd.ProductId\n\tWHERE dotd.Id > `PageSize` * `PageIndex`\n\tORDER BY dotd.Id\n    limit `PageSize`;\n\n\tdrop temporary table if exists `FilteredSpecificationAttributesToProduct`;\n\tdrop temporary table if exists `FilteredProductAttributesToProduct`;\n\tdrop temporary table if exists `PotentialProductVariantAttributeIds`;\n\tdrop temporary table if exists `ProductIdsBeforeFiltersApplied`;\n\tdrop temporary table if exists `FilteredSpecificationAttributeOptions`;\n\tdrop temporary table if exists `FilterableSpecs`;\n\tdrop temporary table if exists `FilteredSpecificationAttributes`;\n\tdrop temporary table if exists `FilterableSpecsDistinct`;\n\tdrop temporary table if exists `PotentialProductSpecificationAttributeIds`;\n\tdrop temporary table if exists `FilteredProductVariantAttributeIds`;\n\tdrop temporary table if exists `FilteredProductAttributes`;\n\tdrop temporary table if exists `FilterableProductVariantIds`;\n\tdrop temporary table if exists `FilterableProductVariantIdsDistinct`;\n\tdrop temporary table if exists `FilteredManufacturerIds`;\n\tdrop temporary table if exists `FilterableManufacturers`;\n\tdrop temporary table if exists `FilterableVendors`;\n    \n\tdrop temporary TABLE if exists `KeywordProducts`;\n\tdrop temporary TABLE if exists `FilteredCategoryIds`;\n\tdrop temporary TABLE if exists `FilteredVendorIds`;\n\tdrop temporary TABLE if exists `FilteredCustomerRoleIds`;\n\tdrop temporary TABLE if exists `DisplayOrderTmp`;\n\tdrop temporary TABLE if exists `DisplayOrderTmpDistinct`;\n\tdrop temporary TABLE if exists `KeepRows`;\n\nEND$$\nDELIMITER ;";

        private string DropProcedureSql = "DROP PROCEDURE IF EXISTS `ProductLoadAllPagedNopAjaxFilters`";

        public AjaxFiltersDatabaseServiceMySQL(INopDataProvider dataProvider, IEncryptionService encryptionService, ISettingService settingService)
        {
            _dataProvider = dataProvider;
            _encryptionService = encryptionService;
            _settingService = settingService;
        }

        public async Task CreateDatabaseScriptsAsync()
        {
            await ExecuteCreateDatabaseScriptsAsync();
            string encryptedDatabaseKey = GenerateEncryptedDatabaseKey();
            NopAjaxFiltersSettings nopAjaxFiltersSettings = await _settingService.LoadSettingAsync<NopAjaxFiltersSettings>();
            nopAjaxFiltersSettings.EncryptedDatabaseHashKey = encryptedDatabaseKey;
            await _settingService.SaveSettingAsync(nopAjaxFiltersSettings);
        }

        public async Task RemoveDatabaseScriptsAsync()
        {
            await ExecuteDropDatabaseScriptsAsync();
        }

        public async Task UpdateDatabaseScriptsAsync()
        {
            string encryptedDatabaseHashKey = GenerateEncryptedDatabaseKey();
            string encryptedDatabaseHashKey2 = (await _settingService.LoadSettingAsync<NopAjaxFiltersSettings>()).EncryptedDatabaseHashKey;
            if (string.IsNullOrEmpty(encryptedDatabaseHashKey2) || !string.Equals(encryptedDatabaseHashKey, encryptedDatabaseHashKey2, StringComparison.Ordinal))
            {
                await RemoveDatabaseScriptsAsync();
                await CreateDatabaseScriptsAsync();
            }
        }

        private async Task ExecuteDropDatabaseScriptsAsync()
        {
            await _dataProvider.ExecuteNonQueryAsync(DropProcedureSql);
            NopAjaxFiltersSettings nopAjaxFiltersSettings = await _settingService.LoadSettingAsync<NopAjaxFiltersSettings>();
            nopAjaxFiltersSettings.EncryptedDatabaseHashKey = string.Empty;
            await _settingService.SaveSettingAsync(nopAjaxFiltersSettings);
        }

        private List<string> GetCommandsFromScript(string sql)
        {
            List<string> list = new List<string>();
            string[] array = Regex.Split(sql, "DELIMITER \\;", RegexOptions.IgnoreCase | RegexOptions.Multiline);
            if (array.Length != 0)
            {
                list.AddRange(array.Where((string b) => !string.IsNullOrWhiteSpace(b)).Select(delegate (string b)
                {
                    b = Regex.Replace(b, "(DELIMITER )?\\$\\$", string.Empty);
                    b = Regex.Replace(b, "#(.*?)\\r?\\n", "/* $1 */");
                    b = Regex.Replace(b, "(\\r?\\n)|(\\t)", " ");
                    return b;
                }));
            }
            return list;
        }

        private async Task ExecuteSqlScript(string sql)
        {
            string sql2 = GetCommandsFromScript(sql).FirstOrDefault();
            await _dataProvider.ExecuteNonQueryAsync(sql2);
        }

        private async Task ExecuteCreateDatabaseScriptsAsync()
        {
            await ExecuteSqlScript(CreateStoredProcedureSql);
        }

        private string GetFileContent()
        {
            string path = "~/ProductLoadAllPagedNopAjaxFilters.MySQL.sql";
            INopFileProvider nopFileProvider = EngineContext.Current.Resolve<INopFileProvider>();
            path = nopFileProvider.MapPath(path);
            if (!nopFileProvider.FileExists(path))
            {
                return string.Empty;
            }
            return nopFileProvider.ReadAllText(path, Encoding.Default);
        }

        private string GenerateEncryptedDatabaseKey()
        {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.Append(DropProcedureSql);
            stringBuilder.Append(CreateStoredProcedureSql);
            return _encryptionService.CreatePasswordHash(stringBuilder.ToString(), "SS_AjaxFilters_EK_351", "SHA1");
        }
    }
}